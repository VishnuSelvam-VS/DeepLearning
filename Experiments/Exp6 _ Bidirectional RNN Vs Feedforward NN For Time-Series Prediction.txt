# Step 1: Import Libraries
import pandas as pd, numpy as np, torch, torch.nn as nn
from torch.utils.data import DataLoader, TensorDataset
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt

# Step 2: Load and Scale Data
url = 'https://raw.githubusercontent.com/jbrownlee/Datasets/master/airline-passengers.csv'
data = pd.read_csv(url, usecols=[1]).values.astype('float32')
scaler = MinMaxScaler((0, 1))
data_scaled = scaler.fit_transform(data)

# Step 3: Create Sequences
SEQ_LEN = 10
X = np.array([data_scaled[i:i+SEQ_LEN] for i in range(len(data_scaled)-SEQ_LEN)])
y = np.array([data_scaled[i+SEQ_LEN] for i in range(len(data_scaled)-SEQ_LEN)])
split = int(len(X)*0.8)
X_train, X_test, y_train, y_test = map(torch.tensor, [X[:split], X[split:], y[:split], y[split:]])
train_loader = DataLoader(TensorDataset(X_train, y_train), batch_size=16, shuffle=True)

# Step 4: Define Models
class BiRNN(nn.Module):
    def __init__(self):
        super().__init__()
        self.rnn = nn.RNN(1, 64, batch_first=True, bidirectional=True)
        self.fc = nn.Linear(128, 1)
    def forward(self, x): return self.fc(self.rnn(x)[0][:, -1, :])

class FFNN(nn.Module):
    def __init__(self):
        super().__init__()
        self.net = nn.Sequential(nn.Linear(SEQ_LEN, 64), nn.ReLU(), nn.Linear(64, 1))
    def forward(self, x): return self.net(x.view(x.size(0), -1))

# Step 5: Train Function
def train(model, loader, epochs=100):
    opt, loss_fn = torch.optim.Adam(model.parameters(), lr=0.01), nn.MSELoss()
    for e in range(epochs):
        for Xb, yb in loader:
            opt.zero_grad(); loss_fn(model(Xb), yb).backward(); opt.step()
        if (e+1)%20==0: print(f'Epoch {e+1}: Loss={loss_fn(model(Xb), yb):.5f}')

# Step 6: Train and Evaluate
birnn, ffnn = BiRNN(), FFNN()
for m in [birnn, ffnn]: train(m, train_loader)
pred_birnn = birnn(X_test).detach().numpy()
pred_ffnn = ffnn(X_test).detach().numpy()

# Step 7: Plot and Evaluate
y_test_inv = scaler.inverse_transform(y_test)
pred_birnn_inv = scaler.inverse_transform(pred_birnn)
pred_ffnn_inv = scaler.inverse_transform(pred_ffnn)

plt.plot(y_test_inv, label='Actual')
plt.plot(pred_birnn_inv, label='BiRNN')
plt.plot(pred_ffnn_inv, label='FFNN')
plt.legend(); plt.title('BiRNN vs FFNN'); plt.show()

print(f"BiRNN MSE: {mean_squared_error(y_test_inv, pred_birnn_inv):.3f}")
print(f"FFNN MSE: {mean_squared_error(y_test_inv, pred_ffnn_inv):.3f}")
